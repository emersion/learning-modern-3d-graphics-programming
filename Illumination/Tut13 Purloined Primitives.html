<html><head>


<script type="text/javascript" src="/static/js/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app18.us.archive.org";archive_analytics.values.server_ms=221;</script>
<link type="text/css" rel="stylesheet" href="/static/css/banner-styles.css"/>


      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <meta http-equiv="X-UA-Compatible" content="IE=Edge"><title>Purloined Primitives</title><link rel="stylesheet" href="chunked.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="../index.html" title="Learning Modern 3D Graphics Programming"><link rel="up" href="Tutorial 13.html" title="Chapter&nbsp;13.&nbsp;Lies and Impostors"><link rel="prev" href="Tut13 Deceit in Depth.html" title="Deceit in Depth"><link rel="next" href="Tut13 In Review.html" title="In Review"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="/static/js/disclaim-element.js" ></script>
<script type="text/javascript" src="/static/js/graph-calc.js" ></script>
<script type="text/javascript" src="/static/jflot/jquery.min.js" ></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.arcsynthesis.org/gltut/Illumination/Tut13%20Purloined%20Primitives.html";

var firstYear = 1996;
var imgWidth = 500,imgHeight = 27;
var yearImgWidth = 25,monthImgWidth = 2;
var displayDay = "25";
var displayMonth = "Feb";
var displayYear = "2015";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function getElementX2(obj) {
  var $e=jQuery(obj);
  return (typeof $e=="undefined"||typeof $e.offset=="undefined")?
    getElementX(obj):Math.round($e.offset().left);
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX2(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})();//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>
<div id="wm-ipp" lang="en" style="display:none;">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="/web/" title="Wayback Machine home page"><img src="/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0" /></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.arcsynthesis.org/gltut/Illumination/Tut13%20Purloined%20Primitives.html" style="width:400px;" onfocus="this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20150225192603" /><input type="submit" value="Go" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="/web/20140813154649/http://www.arcsynthesis.org/gltut/Illumination/Tut13%20Purloined%20Primitives.html" title="13 Aug 2014">AUG</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 19:26:03 Feb 25, 2015">FEB</td>
		<td class="f" nowrap="nowrap">
		
		    Mar
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="/web/20140813154649/http://www.arcsynthesis.org/gltut/Illumination/Tut13%20Purloined%20Primitives.html" title="15:46:49 Aug 13, 2014"><img src="/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 19:26:03 Feb 25, 2015">25</td>
	       <td class="f" nowrap="nowrap">
               
                   <img src="/static/images/toolbar/wm_tb_nxt_off.png" alt="Next capture" width="14" height="16" border="0"/>
               
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="/web/20131205210126/http://www.arcsynthesis.org/gltut/Illumination/Tut13%20Purloined%20Primitives.html" title="5 Dec 2013"><strong>2013</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 19:26:03 Feb 25, 2015">2015</td>
	       <td class="f" nowrap="nowrap">
               
                   2016
               
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="/web/20150225192603*/http://www.arcsynthesis.org/gltut/Illumination/Tut13%20Purloined%20Primitives.html" title="See a list of every capture for this URL">32 captures</a>
           <div class="r" title="Timespan for captures of this URL">13 May 11 - 25 Feb 15</div>
       </td>
       <td class="k">
       <a href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines"
		 onmouseover="__wm.st(1)" onmouseout="__wm.st(0)"
		 onmousemove="__wm.mv(event,this)"
		 width="500"
		 height="27"
		 border="0"
		 src="/web/jsp/graph.jsp?graphdata=500_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000000_2007:-1:000000000000_2008:-1:000000000000_2009:-1:000000000000_2010:-1:000000000000_2011:-1:000010121121_2012:-1:211110000131_2013:-1:001011111111_2014:-1:000100010000_2015:1:010000000000" />
       </div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>
<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->
<div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Purloined Primitives</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="Tut13 Deceit in Depth.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;13.&nbsp;Lies and Impostors</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="Tut13 In Review.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e13040"></a>Purloined Primitives</h2></div></div></div><p>Our method of rendering impostor spheres is very similar to our method of rendering
            mesh spheres. In both cases, we set uniforms that define the sphere's position and
            radius. We bind a material uniform buffer, then bind a VAO and execute a draw command.
            We do this for each sphere.</p><p>However, this seems rather wasteful for impostors. Our per-vertex data for the
            impostor is really the position and the radius. If we could somehow send this data 4
            times, once for each square, then we could simply put all of our position and radius
            values in a buffer object and render every sphere in one draw call. Of course, we would
            also need to find a way to tell it which material to use.</p><p>We accomplish this task in the <span class="propername">Geometry Impostor</span>
            tutorial project. It looks exactly the same as before; it always draws impostors, using
            the depth-accurate shader.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13053"></a>Impostor Interleaving</h3></div></div></div><p>To see how this works, we will start from the front of the rendering pipeline and
                follow the data. This begins with the buffer object and vertex array object we use
                to render.</p><div class="example"><a name="d0e13058"></a><p class="title"><b>Example&nbsp;13.5.&nbsp;Impostor Geometry Creation</b></p><div class="example-contents"><pre class="programlisting">glBindBuffer(GL_ARRAY_BUFFER, g_imposterVBO);
glBufferData(GL_ARRAY_BUFFER, NUMBER_OF_SPHERES * <span class="code-number">4</span> * <span class="code-keyword">sizeof</span>(<span class="code-keyword">float</span>), NULL, GL_STREAM_DRAW);

glGenVertexArrays(<span class="code-number">1</span>, &amp;g_imposterVAO);
glBindVertexArray(g_imposterVAO);
glEnableVertexAttribArray(<span class="code-number">0</span>);
glVertexAttribPointer(<span class="code-number">0</span>, <span class="code-number">3</span>, GL_FLOAT, GL_FALSE, <span class="code-number">4</span> * <span class="code-keyword">sizeof</span>(<span class="code-keyword">float</span>), (<span class="code-keyword">void</span>*)(<span class="code-number">0</span>));
glEnableVertexAttribArray(<span class="code-number">1</span>);
glVertexAttribPointer(<span class="code-number">1</span>, <span class="code-number">1</span>, GL_FLOAT, GL_FALSE, <span class="code-number">4</span> * <span class="code-keyword">sizeof</span>(<span class="code-keyword">float</span>), (<span class="code-keyword">void</span>*)(<span class="code-number">12</span>));

glBindVertexArray(<span class="code-number">0</span>);
glBindBuffer(GL_ARRAY_BUFFER, <span class="code-number">0</span>);</pre></div></div><br class="example-break"><p>This code introduces us to a new feature of
                    <code class="function">glVertexAttribPointer</code>. In all prior cases the fifth
                parameter was 0. Now it is <code class="literal">4 * sizeof(float)</code>. What does this
                parameter mean?</p><p>This parameter is the array's <code class="varname">stride</code>. It is the number of bytes
                from one value for this attribute to the next in the buffer. When this parameter is
                0, that means that the actual stride is the size of the base type
                    (<code class="literal">GL_FLOAT</code> in our case) times the number of components. When
                the stride is non-zero, it must be larger than that value.</p><p>What this means for our vertex data is that the first 3 floats represent attribute
                0, and the next float represents attribute 1. The next 3 floats is attribute 0 of
                the next vertex, and the float after that is attribute 1 of that vertex. And so
                on.</p><p>Arranging attributes of the same vertex alongside one another is called
                    <em class="glossterm">interleaving</em>. It is a very useful technique; indeed, for
                performance reasons, data should generally be interleaved where possible. One thing
                that it allows us to do is build our vertex data based on a struct:</p><pre class="programlisting"><span class="code-keyword">struct</span> VertexData
{
    glm::vec3 cameraPosition;
    <span class="code-keyword">float</span> sphereRadius;
};</pre><p>Our vertex array object perfectly describes the arrangement of data in an array of
                    <code class="classname">VertexData</code> objects. So when we upload our positions and
                radii to the buffer object, we simply create an array of these structs, fill in the
                values, and upload them with <code class="function">glBufferData</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d0e13096"></a>Misnamed and Maligned</h3></div></div></div><p>So, our vertex data now consists of a position and a radius. But we need to draw
                four vertices, not one. How do we do that?</p><p>We could replicate each vertex data 4 times and use some simple
                    <code class="varname">gl_VertexID</code> math in the vertex shader to figure out which
                corner we're using. Or we could get complicated and learn something new. That new
                thing is an entirely new programmatic shader stage: <em class="glossterm">geometry
                    shaders</em>.</p><p>Our initial pipeline discussion ignored this shader stage, because it is an
                entirely optional part of the pipeline. If a program object does not contain a
                geometry shader, then OpenGL just does its normal stuff.</p><p>The most confusing thing about geometry shaders is that they do not shade
                geometry. Vertex shaders take a vertex as input and write a vertex as output.
                Fragment shader take a fragment as input and potentially writes a fragment as
                output. Geometry shaders take a <span class="emphasis"><em>primitive</em></span> as input and write
                zero or more primitives as output. By all rights, they should be called
                    <span class="quote">&#8220;<span class="quote">primitive shaders.</span>&#8221;</span></p><p>In any case, geometry shaders are invoked just after the hardware that collects
                vertex shader outputs into a primitive, but before any clipping, transforming or
                rasterization happens. Geometry shaders get the values output from multiple vertex
                shaders, performs arbitrary computations on them, and outputs one or more sets of
                values to new primitives.</p><p>In our case, the logic begins with our drawing call:</p><pre class="programlisting">glBindVertexArray(g_imposterVAO);
glDrawArrays(GL_POINTS, <span class="code-number">0</span>, NUMBER_OF_SPHERES);
glBindVertexArray(<span class="code-number">0</span>);</pre><p>This introduces a completely new primitive and primitive type:
                    <code class="literal">GL_POINTS.</code> Recall that multiple primitives can have the same
                base type. <code class="literal">GL_TRIANGLE_STRIP</code> and <code class="literal">GL_TRIANGLES</code>
                are both separate primitives, but both generate triangles.
                    <code class="literal">GL_POINTS</code> does not generate triangle primitives; it generates
                point primitives.</p><p><code class="literal">GL_POINTS</code> interprets each individual vertex as a separate point
                primitive. There are no other forms of point primitives, because points only contain
                a single vertex worth of information.</p><p>The vertex shader is quite simple, but it does have some new things to show
                us:</p><div class="example"><a name="d0e13144"></a><p class="title"><b>Example&nbsp;13.6.&nbsp;Vertex Shader for Points</b></p><div class="example-contents"><pre class="programlisting">#version <span class="code-number">330</span>

<span class="code-modifier">layout</span>(location = <span class="code-number">0</span>) <span class="code-modifier">in</span> <span class="code-type">vec3</span> cameraSpherePos;
<span class="code-modifier">layout</span>(location = <span class="code-number">1</span>) <span class="code-modifier">in</span> <span class="code-type">float</span> sphereRadius;

<span class="code-modifier">out</span> VertexData
{
    <span class="code-type">vec3</span> cameraSpherePos;
    <span class="code-type">float</span> sphereRadius
} outData;

<span class="code-type">void</span> main()
{
	outData.cameraSpherePos = cameraSpherePos;
    outData.sphereRadius = sphereRadius;
}</pre></div></div><br class="example-break"><p><code class="classname">VertexData</code> is not a struct definition, though it does look
                like one. It is an <em class="glossterm">interface block</em> definition. Uniform blocks
                are a kind of interface block, but inputs and outputs can also have interface
                blocks.</p><p>An interface block used for inputs and outputs is a way of collecting them into
                groups. One of the main uses for these is to separate namespaces of inputs and
                outputs using the interface name (<code class="varname">outData</code>, in this case). This
                allows us to use the same names for inputs as we do for their corresponding outputs.
                They do have other virtues, as we will soon see.</p><p>Do note that this vertex shader does not write to <code class="varname">gl_Position.</code>
                That is not necessary when a vertex shader is paired with a geometry shader.</p><p>Speaking of which, let's look at the global definitions of our geometry
                shader.</p><div class="example"><a name="d0e13168"></a><p class="title"><b>Example&nbsp;13.7.&nbsp;Geometry Shader Definitions</b></p><div class="example-contents"><pre class="programlisting">#version <span class="code-number">330</span>
<span class="code-directive">#extension GL_EXT_gpu_shader4 : enable</span>

<span class="code-modifier">layout</span>(std140) <span class="code-modifier">uniform</span>;
<span class="code-modifier">layout</span>(points) <span class="code-modifier">in</span>;
<span class="code-modifier">layout</span>(triangle_strip, max_vertices=<span class="code-number">4</span>) <span class="code-modifier">out</span>;

<span class="code-modifier">uniform</span> Projection
{
    <span class="code-type">mat4</span> cameraToClipMatrix;
};

<span class="code-modifier">in</span> VertexData
{
    <span class="code-type">vec3</span> cameraSpherePos;
    <span class="code-type">float</span> sphereRadius;
} vert[];

<span class="code-modifier">out</span> FragData
{
    <span class="code-modifier">flat</span> <span class="code-type">vec3</span> cameraSpherePos;
    <span class="code-modifier">flat</span> <span class="code-type">float</span> sphereRadius;
    <span class="code-modifier">smooth</span> <span class="code-type">vec2</span> mapping;
};</pre></div></div><br class="example-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="literal">#extension</code> line exists to fix a compiler bug for
                    NVIDIA's OpenGL. It should not be necessary.</p></div><p>We see some new uses of the <code class="literal">layout</code> directive. The
                    <code class="literal">layout(points) in</code> command is geometry shader-specific. It
                tells OpenGL that this geometry shader is intended to take point primitives. This is
                required; also, OpenGL will fail to render if you try to draw something other than
                    <code class="literal">GL_POINTS</code> through this geometry shader.</p><p>Similarly, the output layout definition states that this geometry shader outputs
                triangle strips. The <code class="literal">max_vertices</code> directive states that we will
                write at most 4 vertices. There are implementation defined limits on how large
                    <code class="literal">max_vertices</code> can be. Both of these declarations are required
                for geometry shaders.</p><p>Below the <code class="classname">Projection</code> uniform block, we have two interface
                blocks. The first one matches the definition from the vertex shader, with two
                exceptions. It has a different interface name. But that interface name also has an
                array qualifier on it.</p><p>Geometry shaders take a primitive. And a primitive is defined as some number of
                vertices in a particular order. The input interface blocks define what the input
                vertex data is, but there is more than one set of vertex data. Therefore, the
                interface blocks must be defined as arrays. Granted, in our case, it is an array of
                length 1, since point primitives have only one vertex. But this is still necessary
                even in that case.</p><p>We also have another output fragment block. This one matches the definition from
                the fragment shader, as we will see a bit later. It does not have an instance name.
                Also, note that several of the values use the <code class="literal">flat</code> qualifier. We
                could have just used <code class="literal">smooth</code>, since we're passing the same values
                for all of the triangles. However, it's more descriptive to use the
                    <code class="literal">flat</code> qualifier for values that are not supposed to be
                interpolated. It might even save performance.</p><p>Here is the geometry shader code for computing one of the vertices of the output
                triangle strip:</p><div class="example"><a name="d0e13218"></a><p class="title"><b>Example&nbsp;13.8.&nbsp;Geometry Shader Vertex Computation</b></p><div class="example-contents"><pre class="programlisting"><span class="code-comment">//Bottom-left</span>
mapping = <span class="code-type">vec2</span>(-<span class="code-number">1.0</span>, -<span class="code-number">1.0</span>) * g_boxCorrection;
cameraSpherePos = <span class="code-type">vec3</span>(vert[<span class="code-number">0</span>].cameraSpherePos);
sphereRadius = vert[<span class="code-number">0</span>].sphereRadius;
cameraCornerPos = <span class="code-type">vec4</span>(vert[<span class="code-number">0</span>].cameraSpherePos, <span class="code-number">1.0</span>);
cameraCornerPos.xy += <span class="code-type">vec2</span>(-vert[<span class="code-number">0</span>].sphereRadius, -vert[<span class="code-number">0</span>].sphereRadius) * g_boxCorrection;
gl_Position = cameraToClipMatrix * cameraCornerPos;
gl_PrimitiveID = gl_PrimitiveIDIn;
<span class="code-function">EmitVertex</span>();</pre></div></div><br class="example-break"><p>This code is followed by three more of these, using different mapping and offset
                values for the different corners of the square. The
                    <code class="varname">cameraCornerPos</code> is a local variable that is re-used as
                temporary storage.</p><p>To output a vertex, write to each of the output variables. In this case, we have
                the three from the output interface block, as well as the built-in variables
                    <code class="varname">gl_Position</code> and <code class="varname">gl_PrimitiveID</code> (which we
                will discuss more in a bit). Then, call <code class="function">EmitVertex()</code>; this
                causes all of the values in the output variables to be transformed into a vertex
                that is sent to the output primitive type. After calling this function, the contents
                of those outputs are undefined. So if you want to use the same value for multiple
                vertices, you have to store the value in a different variable or recompute
                it.</p><p>Note that clipping, face-culling, and all of that stuff happens after the geometry
                shader. This means that we must ensure that the order of our output positions will
                be correct given the current winding order.</p><p><code class="varname">gl_PrimitiveIDIn</code> is a special input value. Much like
                    <code class="varname">gl_VertexID</code> from the vertex shader,
                    <code class="varname">gl_PrimitiveIDIn</code> represents the current primitive being
                processed by the geometry shader (once more reason for calling it a primitive
                shader). We write this to the built-in output <code class="varname">gl_PrimitiveID</code>, so
                that the fragment shader can use it to select which material to use.</p><p>And speaking of the fragment shader, it's time to have a look at that.</p><div class="example"><a name="d0e13256"></a><p class="title"><b>Example&nbsp;13.9.&nbsp;Fragment Shader Changes</b></p><div class="example-contents"><pre class="programlisting"><span class="code-modifier">in</span> FragData
{
    <span class="code-modifier">flat</span> <span class="code-type">vec3</span> cameraSpherePos;
    <span class="code-modifier">flat</span> <span class="code-type">float</span> sphereRadius;
    <span class="code-modifier">smooth</span> <span class="code-type">vec2</span> mapping;
};

<span class="code-modifier">out</span> <span class="code-type">vec4</span> outputColor;

<span class="code-modifier">layout</span>(std140) <span class="code-modifier">uniform</span>;

<span class="code-keyword">struct</span> MaterialEntry
{
    <span class="code-type">vec4</span> diffuseColor;
    <span class="code-type">vec4</span> specularColor;
    <span class="code-type">vec4</span> specularShininess;        <span class="code-comment">//ATI Array Bug fix. Not really a vec4.</span>
};

<span class="code-modifier">const</span> <span class="code-type">int</span> NUMBER_OF_SPHERES = <span class="code-number">4</span>;

<span class="code-modifier">uniform</span> Material
{
    MaterialEntry material[NUMBER_OF_SPHERES];
} Mtl;</pre></div></div><br class="example-break"><p>The input interface is just the mirror of the output from the geometry shader.
                What's more interesting is what happened to our material blocks.</p><p>In our original code, we had an array of uniform blocks stored in a single uniform
                buffer in C++. We bound specific portions of this material block when we wanted to
                render with a particular material. That will not work now that we are trying to
                render multiple spheres in a single draw call.</p><p>So, instead of having an array of uniform blocks, we have a uniform block that
                    <span class="emphasis"><em>contains</em></span> an array. We bind all of the materials to the
                shader, and let the shader pick which one it wants as needed. The source code to do
                this is pretty straightforward.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Notice that the material <code class="varname">specularShininess</code> became a
                        <span class="type">vec4</span> instead of a simple <span class="type">float</span>. This is due to an
                    unfortunate bug in ATI's OpenGL implementation.</p></div><p>As for how the material selection happens, that's simple. In our case, we use the
                primitive identifier. The <code class="varname">gl_PrimitiveID</code> value written from the
                vertex shader is used to index into the <code class="varname">Mtl.material[]</code>
                array.</p><p>Do note that uniform blocks have a maximum size that is hardware-dependent. If we
                wanted to have a large palette of materials, on the order of several thousand, then
                we may exceed this limit. At that point, we would need an entirely new way to handle
                this data. Once that we have not learned about yet.</p><p>Or we could just split it up into multiple draw calls instead of one.</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="Tut13 Deceit in Depth.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="Tutorial 13.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="Tut13 In Review.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Deceit in Depth&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="/web/20150225192603/http://www.arcsynthesis.org/gltut/index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;In Review</td></tr></table></div></body></html>




<!--
     FILE ARCHIVED ON 19:26:03 Feb 25, 2015 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 19:09:54 Mar 29, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
